#version 460

#ifdef GLSLANGVALIDATOR
    // otherwise glslangValidator complains about #include
    //for OpenGL they will be replaced when shader is loaded
    #extension GL_GOOGLE_include_directive : require
#endif

layout (binding = 0) uniform sampler2D visbufferTex;
layout (binding = 1) uniform sampler2D posTex;
layout (binding = 2) uniform usampler2D materialIDTex;

#define ONLY_DEFINES
#include "transform.glsl"

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

/*
    Pixel groups are:
        All materials have same ID and use top-down projection
        All materials have same ID and use biplanar projection
        Materials have different IDs but all use top-down projection
        Materials have different IDs and one sample uses biplanar projection
        Materials have different IDs and two samples uses biplanar projection
        Materials have different IDs and three samples uses biplanar projection
        Materials have different IDs and all samples uses biplanar projection
*/
//First used as counter to count how many pixels in workgroup are part of each group
//then used to reserve that many slots in the pixel array and store the start indices
shared uint workgroupStartIndexInGroup[7];
layout(std430, binding = 4) buffer pixelBuffer
{   
    uint perGroupStartIndex[7];
    uint perGroupCurrentIndex[7];
    uint pixels[];
};

void main()
{
    if(gl_LocalInvocationID.y == 0 && gl_LocalInvocationID.x < 7)
    {
        workgroupStartIndexInGroup[gl_LocalInvocationID.x] = 0;
    }
    barrier();

    uvec2 resolution = textureSize(visbufferTex, 0);
    const uvec2 threadID = gl_GlobalInvocationID.xy;
    
    uint group = 0xFFFFFFFF;
    uint startIndexRelativeToWorkgroup = 0;
    if (threadID.x < resolution.x && threadID.y < resolution.y)
    {
        vec4 visBuffer = texelFetch(visbufferTex, ivec2(threadID), 0);
        if(visBuffer.w < 1)
        {
            vec3 worldPosNoDisplacement = texelFetch(posTex, ivec2(threadID), 0).rgb;
            vec2 flatPosition = worldPosNoDisplacement.xz/TERRAIN_SIZE;
            vec2 uv = vec2(1,-1) * flatPosition + 0.5;
            
            const vec2 scaledUVs = uv*textureSize(materialIDTex,0);
            const ivec2 idsStartTexel = ivec2(scaledUVs);
    
            const uint materialIDFF = texelFetchOffset(materialIDTex, idsStartTexel, 0, ivec2(0,0)).r;
            const uint materialIDFC = texelFetchOffset(materialIDTex, idsStartTexel, 0, ivec2(0,1)).r;
            const uint materialIDCF = texelFetchOffset(materialIDTex, idsStartTexel, 0, ivec2(1,0)).r;
            const uint materialIDCC = texelFetchOffset(materialIDTex, idsStartTexel, 0, ivec2(1,1)).r;

            if(materialIDFF == materialIDFC && materialIDFC == materialIDCF && materialIDCF == materialIDCC)
            {
                if((materialIDFF & 128u) == 128u)
                {
                    group = 1;
                }
                else
                {
                    group = 0;
                }
            }
            else
            {
                group = 2;
                group += (materialIDFF & 128u) >> 7;
                group += (materialIDFC & 128u) >> 7;
                group += (materialIDCF & 128u) >> 7;
                group += (materialIDCC & 128u) >> 7;
            }
            startIndexRelativeToWorkgroup = atomicAdd(workgroupStartIndexInGroup[group], 1u);
        }
    }

    barrier();

    if(gl_LocalInvocationID.y == 0 && gl_LocalInvocationID.x < 7)
    {
        workgroupStartIndexInGroup[gl_LocalInvocationID.x] =
            atomicAdd(perGroupCurrentIndex[gl_LocalInvocationID.x],workgroupStartIndexInGroup[gl_LocalInvocationID.x]);
    }

    barrier();

    if(group != 0xFFFFFFFF)
    {
        uint packedPixelPos = ((threadID.x & 0x0000FFFF) << 16u) | (threadID.y & 0x0000FFFF);

        uint combinedIndex = startIndexRelativeToWorkgroup + workgroupStartIndexInGroup[group];
        pixels[combinedIndex] = packedPixelPos;
    }
}