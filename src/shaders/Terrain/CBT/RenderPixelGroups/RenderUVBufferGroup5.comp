#version 460

#ifdef GLSLANGVALIDATOR
    // otherwise glslangValidator complains about #include
    //for OpenGL they will be replaced when shader is loaded
    #extension GL_GOOGLE_include_directive : require

    #ifndef SHADING_GROUP_SIZE
        #define SHADING_GROUP_SIZE 64
    #endif
#endif

layout (binding = 1) uniform sampler2D macroNormal;
layout (binding = 2) uniform usampler2D materialIDTex;
layout (binding = 4) uniform sampler2DArray diffuseArray;
layout (binding = 5) uniform sampler2DArray normalArray;
layout (binding = 6) uniform sampler2DArray ordArray;
layout (binding = 7) uniform sampler2D visbufferTex;
layout (binding = 8) uniform sampler2D posTex;
layout (binding = 9) uniform sampler2D trueDepthBuffer;

uniform layout(r11f_g11f_b10f, binding = 0) writeonly restrict image2D colorOutImage;

#include "../../../General/CameraMatrices.glsl"
layout(binding = 1) uniform PassMatricesBuffer
{
    CameraMatrices cameraMatrices;
};

#include "../../SettingsStruct.glsl"
layout(binding = 4) uniform terrainSettingsBuffer
{
    TerrainSettings terrainSettings;
};

layout(std430, binding = 3) buffer textureInfoBuffer
{   
    float textureScales[];
};

// Reorient normal blending for blending material normal maps and terrain normal:
// https://blog.selfshadow.com/publications/blending-in-detail/
vec3 reorientNormalBlend(vec3 t, vec3 u)
{
    t += vec3(0,0,1);
    u *= vec3(-1,-1,1);
    return normalize(t*dot(t, u) - u*t.z);
}

#define ONLY_DEFINES
#include "../transform.glsl"
#include "../FetchAttributesFromID.glsl"
#include "../../../General/lighting.glsl"

vec3 worldPositionFromDepth(vec2 texCoord, float depthBufferDepth)
{
    vec4 posClipSpace = vec4(texCoord * 2.0 - vec2(1.0), 2.0 * depthBufferDepth - 1.0, 1.0);
    vec4 posWorldSpace = cameraMatrices.invProjView * posClipSpace;
    return(posWorldSpace.xyz / posWorldSpace.w);
}
vec3 viewPositionFromDepth(vec2 texCoord, float depthBufferDepth)
{
    vec4 posClipSpace = vec4(texCoord * 2.0 - vec2(1.0), 2.0 * depthBufferDepth - 1.0, 1.0);
    vec4 posViewSpace = cameraMatrices.invProj * posClipSpace;
    return(posViewSpace.xyz / posViewSpace.w);
}

void swap(inout uint v1, inout uint v2)
{
    const uint t = v1;
    v1 = v2;
    v2 = t;
}

/*
    Pixel groups are:
        All materials have same ID and use top-down projection
        All materials have same ID and use biplanar projection
        Materials have different IDs but all use top-down projection
        Materials have different IDs and one sample uses biplanar projection
        Materials have different IDs and two samples uses biplanar projection
        Materials have different IDs and three samples uses biplanar projection
        Materials have different IDs and all samples uses biplanar projection
*/
layout(std430, binding = 4) buffer pixelBuffer
{   
    uint perGroupStartIndex[7];
    uint perGroupAmount[7];
    uint pixels[];
};

layout(local_size_x = SHADING_GROUP_SIZE, local_size_y = 1, local_size_z = 1) in;

void main()
{
    const uint threadIndex = gl_GlobalInvocationID.x;
    const uint amountInGroup = perGroupAmount[5];

    if (threadIndex < amountInGroup)
    {
        const uint groupStartIndex = perGroupStartIndex[5];
        const uint packedPixelPos = pixels[groupStartIndex + threadIndex];
        const uvec2 pixelPos = uvec2(
            (packedPixelPos >> 16u) & 0x0000FFFF,
            (packedPixelPos) & 0x0000FFFF
        );

        vec4 visBuffer = texelFetch(visbufferTex, ivec2(pixelPos), 0);

        vec2 screenUV = pixelPos.xy/vec2(textureSize(visbufferTex,0));
        vec3 worldPosNoDisplacement = texelFetch(posTex, ivec2(pixelPos.xy), 0).rgb;

        float trueDepth = texelFetch(trueDepthBuffer, ivec2(pixelPos.xy), 0).r;
        vec3 viewPos = viewPositionFromDepth(screenUV, trueDepth);
        vec3 worldPos = worldPositionFromDepth(screenUV, trueDepth);

        vec2 dX = unpackHalf2x16(floatBitsToUint(visBuffer.r));
        vec2 dY = unpackHalf2x16(floatBitsToUint(visBuffer.g));
        vec2 dZ = unpackHalf2x16(floatBitsToUint(visBuffer.b));
        vec3 dPdx = vec3(dX.x, dY.x, dZ.x);
        vec3 dPdy = vec3(dX.y, dY.y, dZ.y);

        vec2 flatPosition = worldPosNoDisplacement.xz/TERRAIN_SIZE;
        vec2 uv = vec2(1,-1) * flatPosition + 0.5;
        vec2 duvdx = vec2(1,-1)*dPdx.xz/TERRAIN_SIZE;
        vec2 duvdy = vec2(1,-1)*dPdy.xz/TERRAIN_SIZE;

        vec3 macroNormal = 2.0*textureLod(macroNormal, uv, 0).xyz-1.0;

        const vec2 scaledUVs = uv*textureSize(materialIDTex,0);
        const ivec2 idsStartTexel = ivec2(scaledUVs);
        const vec2 weights = fract(scaledUVs);

        uint sampleIndices[4] = uint[4](0,1,2,3);

        const uint materialIDs[4] = uint[4](
            texelFetch(materialIDTex, idsStartTexel+ivec2(0,0), 0).r,
            texelFetch(materialIDTex, idsStartTexel+ivec2(0,1), 0).r,
            texelFetch(materialIDTex, idsStartTexel+ivec2(1,0), 0).r,
            texelFetch(materialIDTex, idsStartTexel+ivec2(1,1), 0).r
        );
        //Find the 1 material that does not need to be sampled biplanar
        for(int i=0; i<4; i++)
        {
            if((materialIDs[i] & 0x80) == 0)
            {
                swap(sampleIndices[0], sampleIndices[i]);
                break;
            }
        }
        //Take all samples
        const MaterialAttributes matAttributes[4] = MaterialAttributes[4](
            getFlatMaterialAttributesFromIndexAndWorldPos(materialIDs[sampleIndices[0]] & 0x7F, worldPosNoDisplacement, dPdx, dPdy, macroNormal),
            getBiplanarMaterialAttributesFromIndexAndWorldPos(materialIDs[sampleIndices[1]] & 0x7F, worldPosNoDisplacement, dPdx, dPdy, macroNormal),
            getBiplanarMaterialAttributesFromIndexAndWorldPos(materialIDs[sampleIndices[2]] & 0x7F, worldPosNoDisplacement, dPdx, dPdy, macroNormal),
            getBiplanarMaterialAttributesFromIndexAndWorldPos(materialIDs[sampleIndices[3]] & 0x7F, worldPosNoDisplacement, dPdx, dPdy, macroNormal)
        );

        const MaterialAttributes maF = lerp(matAttributes[sampleIndices[0]], matAttributes[sampleIndices[1]], weights.y);
        const MaterialAttributes maC = lerp(matAttributes[sampleIndices[2]], matAttributes[sampleIndices[3]], weights.y);
        const MaterialAttributes attributes = lerp(maF, maC, weights.x);
        const vec3 diffuse = attributes.diffuseRoughness.rgb;
        const float roughness = attributes.diffuseRoughness.w;
        const float ambientOcclusion = attributes.aoHeight.x;
        vec3 tangentNormal = attributes.normalMetallic.xyz;
        //TBN columns would just be (1,0,0),(0,0,-1),(0,1,0), so no need for matrix mult here
        vec3 worldNormal = vec3(tangentNormal.x, tangentNormal.z, -tangentNormal.y);

        // Lighting

        vec3 diff = vec3(0,0,0);
        vec3 spec = vec3(0,0,0);

        const vec3 P = viewPos.xyz;
        const vec3 V = normalize(-P);
        const vec3 viewNormal = normalize(cameraMatrices.View * vec4(worldNormal, 0)).xyz;

        vec3 baseColor = diffuse;
        const vec3 reflect = mix(vec3(0.04f, 0.04f, 0.04f), baseColor.xyz, 0.0f);

        directIllumination(cameraMatrices.View, V, P, viewNormal, worldPos, LightColor.xyz, LightDirection, baseColor, roughness, diff, spec);
        imageBasedLighting(cameraMatrices.View, V, viewNormal, worldNormal, reflect, 0.0f, baseColor, diff, spec, roughness, ambientOcclusion);

        diff = any(isnan(diff)) ? vec3(0.0) : diff;
        spec = any(isnan(spec)) ? vec3(0.0) : spec;
        const vec3 col = diff + spec;
        imageStore(colorOutImage, ivec2(pixelPos), vec4(col, 1));
    }
}