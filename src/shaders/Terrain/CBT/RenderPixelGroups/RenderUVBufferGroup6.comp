#version 460

#ifdef GLSLANGVALIDATOR
    // otherwise glslangValidator complains about #include
    //for OpenGL they will be replaced when shader is loaded
    #extension GL_GOOGLE_include_directive : require

    #ifndef SHADING_GROUP_SIZE
        #define SHADING_GROUP_SIZE 64
    #endif
#endif

layout (binding = 1) uniform sampler2D macroNormal;
layout (binding = 2) uniform usampler2D materialIDTex;
layout (binding = 4) uniform sampler2DArray diffuseArray;
layout (binding = 5) uniform sampler2DArray normalArray;
layout (binding = 6) uniform sampler2DArray ordArray;
layout (binding = 7) uniform sampler2D visbufferTex;
layout (binding = 8) uniform sampler2D posTex;
layout (binding = 9) uniform sampler2D trueDepthBuffer;

uniform layout(r11f_g11f_b10f, binding = 0) writeonly restrict image2D colorOutImage;

#include "../../../General/CameraMatrices.glsl"
layout(binding = 1) uniform PassMatricesBuffer
{
    CameraMatrices cameraMatrices;
};

#include "../../SettingsStruct.glsl"
layout(binding = 4) uniform terrainSettingsBuffer
{
    TerrainSettings terrainSettings;
};

layout(std430, binding = 3) buffer textureInfoBuffer
{   
    float textureScales[];
};

#define ONLY_DEFINES
#include "../transform.glsl"
#define ONLY_FUNCTIONS
#include "../FetchAttributes.glsl"
#include "../../../General/lighting.glsl"

vec3 worldPositionFromDepth(vec2 texCoord, float depthBufferDepth)
{
    vec4 posClipSpace = vec4(texCoord * 2.0 - vec2(1.0), 2.0 * depthBufferDepth - 1.0, 1.0);
    vec4 posWorldSpace = cameraMatrices.invProjView * posClipSpace;
    return(posWorldSpace.xyz / posWorldSpace.w);
}
vec3 viewPositionFromDepth(vec2 texCoord, float depthBufferDepth)
{
    vec4 posClipSpace = vec4(texCoord * 2.0 - vec2(1.0), 2.0 * depthBufferDepth - 1.0, 1.0);
    vec4 posViewSpace = cameraMatrices.invProj * posClipSpace;
    return(posViewSpace.xyz / posViewSpace.w);
}

/*
    Pixel groups are:
        All materials have same ID and use top-down projection
        All materials have same ID and use biplanar projection
        Materials have different IDs but all use top-down projection
        Materials have different IDs and one sample uses biplanar projection
        Materials have different IDs and two samples uses biplanar projection
        Materials have different IDs and three samples uses biplanar projection
        Materials have different IDs and all samples uses biplanar projection
*/
layout(std430, binding = 4) buffer pixelBuffer
{   
    uint perGroupStartIndex[7];
    uint perGroupAmount[7];
    uint pixels[];
};

layout(local_size_x = SHADING_GROUP_SIZE, local_size_y = 1, local_size_z = 1) in;

void main()
{
    const uint threadIndex = gl_GlobalInvocationID.x;
    const uint amountInGroup = perGroupAmount[6];

    if (threadIndex < amountInGroup)
    {
        const uint groupStartIndex = perGroupStartIndex[2];
        const uint packedPixelPos = pixels[groupStartIndex + threadIndex];
        const uvec2 pixelPos = uvec2(
            (packedPixelPos >> 16u) & 0x0000FFFF,
            (packedPixelPos) & 0x0000FFFF
        );

        vec4 visBuffer = texelFetch(visbufferTex, ivec2(pixelPos), 0);

        vec2 screenUV = pixelPos.xy/vec2(textureSize(visbufferTex,0));
        vec3 worldPosNoDisplacement = texelFetch(posTex, ivec2(pixelPos.xy), 0).rgb;

        float trueDepth = texelFetch(trueDepthBuffer, ivec2(pixelPos.xy), 0).r;
        vec3 viewPos = viewPositionFromDepth(screenUV, trueDepth);
        vec3 worldPos = worldPositionFromDepth(screenUV, trueDepth);

        vec2 dX = unpackHalf2x16(floatBitsToUint(visBuffer.r));
        vec2 dY = unpackHalf2x16(floatBitsToUint(visBuffer.g));
        vec2 dZ = unpackHalf2x16(floatBitsToUint(visBuffer.b));
        vec3 dPdx = vec3(dX.x, dY.x, dZ.x);
        vec3 dPdy = vec3(dX.y, dY.y, dZ.y);

        vec2 flatPosition = worldPosNoDisplacement.xz/TERRAIN_SIZE;
        vec2 flatUV = vec2(1,-1) * flatPosition + 0.5;
        vec2 duvdx = vec2(1,-1)*dPdx.xz/TERRAIN_SIZE;
        vec2 duvdy = vec2(1,-1)*dPdy.xz/TERRAIN_SIZE;

        const vec3 macroNormalTS = 2.0*textureLod(macroNormal, flatUV, 0).xyz-1.0;
        vec2 biplanarWeights = pow(abs(macroNormalTS.xy),vec2(terrainSettings.triplanarSharpness));
        biplanarWeights /= biplanarWeights.x + biplanarWeights.y;
        float biplanarWeight = biplanarWeights.x;

        const vec2 flipFactorXY = vec2(-sign(macroNormalTS.y), 1);
        const vec2 flipFactorZY = vec2(-sign(macroNormalTS.x), 1);
        
        vec2 uvXY = worldPosNoDisplacement.xy*flipFactorXY;
        vec2 dPdxXY = dPdx.xy*flipFactorXY;
        vec2 dPdyXY = dPdy.xy*flipFactorXY;

        vec2 uvZY = worldPosNoDisplacement.zy*flipFactorZY;
        vec2 dPdxZY = dPdx.zy*flipFactorZY;
        vec2 dPdyZY = dPdy.zy*flipFactorZY;

        const vec2 scaledUVs = flatUV*textureSize(materialIDTex,0);
        const ivec2 idsStartTexel = ivec2(scaledUVs);
        const vec2 weights = fract(scaledUVs);
        const uint materialIDs[4] = uint[4](
            texelFetch(materialIDTex, idsStartTexel+ivec2(0,0), 0).r,
            texelFetch(materialIDTex, idsStartTexel+ivec2(0,1), 0).r,
            texelFetch(materialIDTex, idsStartTexel+ivec2(1,0), 0).r,
            texelFetch(materialIDTex, idsStartTexel+ivec2(1,1), 0).r
        );

        const MaterialAttributes maFF = biplanarSampleOfMaterialAttributesFromID(
                materialIDs[0] & 0x7F, uvXY, dPdxXY, dPdyXY, flipFactorXY, uvZY, dPdxZY, dPdyZY, flipFactorZY, biplanarWeight, macroNormalTS
        );
        const MaterialAttributes maFC = biplanarSampleOfMaterialAttributesFromID(
                materialIDs[1] & 0x7F, uvXY, dPdxXY, dPdyXY, flipFactorXY, uvZY, dPdxZY, dPdyZY, flipFactorZY, biplanarWeight, macroNormalTS
        );
        const MaterialAttributes maCF = biplanarSampleOfMaterialAttributesFromID(
                materialIDs[2] & 0x7F, uvXY, dPdxXY, dPdyXY, flipFactorXY, uvZY, dPdxZY, dPdyZY, flipFactorZY, biplanarWeight, macroNormalTS
        );
        const MaterialAttributes maCC = biplanarSampleOfMaterialAttributesFromID(
                materialIDs[3] & 0x7F, uvXY, dPdxXY, dPdyXY, flipFactorXY, uvZY, dPdxZY, dPdyZY, flipFactorZY, biplanarWeight, macroNormalTS
        );
        const MaterialAttributes maF = lerp(maFF, maFC, weights.y);
        const MaterialAttributes maC = lerp(maCF, maCC, weights.y);
        const MaterialAttributes attributes = lerp(maF, maC, weights.x);
        const vec3 diffuse = attributes.diffuseRoughness.rgb;
        const float roughness = attributes.diffuseRoughness.w;
        const float ambientOcclusion = attributes.aoHeight.x;
        vec3 tangentNormal = attributes.normalMetallic.xyz;
        //TBN columns would just be (1,0,0),(0,0,-1),(0,1,0), so no need for matrix mult here
        vec3 worldNormal = vec3(tangentNormal.x, tangentNormal.z, -tangentNormal.y);

        // Lighting

        vec3 diff = vec3(0,0,0);
        vec3 spec = vec3(0,0,0);

        const vec3 P = viewPos.xyz;
        const vec3 V = normalize(-P);
        const vec3 viewNormal = normalize(cameraMatrices.View * vec4(worldNormal, 0)).xyz;

        vec3 baseColor = diffuse;
        const vec3 reflect = mix(vec3(0.04f, 0.04f, 0.04f), baseColor.xyz, 0.0f);

        directIllumination(cameraMatrices.View, V, P, viewNormal, worldPos, LightColor.xyz, LightDirection, baseColor, roughness, diff, spec);
        imageBasedLighting(cameraMatrices.View, V, viewNormal, worldNormal, reflect, 0.0f, baseColor, diff, spec, roughness, ambientOcclusion);

        diff = any(isnan(diff)) ? vec3(0.0) : diff;
        spec = any(isnan(spec)) ? vec3(0.0) : spec;
        const vec3 col = diff + spec;
        imageStore(colorOutImage, ivec2(pixelPos), vec4(col, 1));
    }
}